////////////////////////////////////////////////////////////////////////////////
//   ____  ____
//  /   /\/   /
// /___/  \  /
// \   \   \/     Vendor : Xilinx
//  \   \         Version : 1.7
//  /   /         Application : GTX Transceiver Wizard
// /___/   /\     Filename : frame_gen.v
// \   \  /  \
//  \___\/\___\
//
//
// Module FRAME_GEN
// Generated by Xilinx GTX Transceiver Wizard
// 
// 
// (c) Copyright 2008 - 2009 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES. 

`include "rc4.inc"
//`include "./ipcores/rs_encoder_v7_1.v"
//`include "./ipcores/user_data_ROM_16384_8.v"
//`include "./ipcores/sigdigit_ROM_276x24.v"

`timescale 1ns / 1ps
`define DLY #1

//***********************************Entity Declaration*******************************

module FRAME_GEN 

(
    // ----- User Interface
    TX_DATA,
    TX_CHARISK, // Unused
    // ----- Debug
    // Received frame count
    FRAME_COUNT,
    // ----- System Interface
    // Clock
    USER_CLK,       
    // Reset
    SYSTEM_RESET,
    // Emit Sync signal
    SYNC,
    // We are busy encrypting
    BUSY,
    // Amount of clients injecting noise
    NOISE_CLIENTS,
    // Noise-only mode
    NOISE_MODE,
    // Debug variables
    DEBUG,
    // Chip select
    CS
); 


//***********************************Port Declarations*******************************

   // User Interface
    output  [31:0]  TX_DATA;
    output  [3:0]   TX_CHARISK;

      // System Interface
    input           USER_CLK;
    input           SYSTEM_RESET;
    input           SYNC;
    output	    BUSY;
    input           CS;
	 
    input   [9:0] NOISE_CLIENTS;
    input   NOISE_MODE;

		// Debug
	 output [31:0] FRAME_COUNT;
    	 output [31:0]    DEBUG;
//********************************* Wire Declarations********************************* 

    wire            tied_to_ground_i;
    wire    [31:0]  tied_to_ground_vec_i;
    wire    [31:0]  tx_data_bram_i;
    wire    [3:0]   tx_charisk_i;
    wire    [3:0]   tx_charisk_float_i;
    wire    [9:0] NOISE_CLIENTS;
    wire    NOISE_MODE;
    wire   CS;
    wire   SYNC;
//***************************Internal Register Declarations*************************** 

    reg     [8:0]   read_counter_i;    
    reg     [3:0]   TX_CHARISK;    
    reg     [31:0]  TX_DATA;
    reg     [31:0]  FRAME_COUNT;
    reg    BUSY;
// Debug (FSM state)
    reg    [31:0]    DEBUG;
    
//*********************************Main Body of Code**********************************

    assign tied_to_ground_vec_i  =   32'h00000000;
    assign tied_to_ground_i      =   1'b0;
    assign tied_to_vcc_i         =   1'b1;
    
    //____________________________ Counter to read from BRAM __________________________    

//---------------------------------------------------
/* RAM/ROM instantiations */
//---------------------------------------------------

// Tamanio bloomfilter
`define M 1024

// Contador de bloques transmitidos
reg [31:0] blockCounter;

// Declaramos Bloomfilter
// Por conveniencia tenemos todos los bloomfilters a transmitir en memoria
// el minimo es 128K (4096*256)
// TODO: Reemplazar por buffer circular
reg [`M-1:0] bloomfilter; 
reg [`M-1:0] bloomfilter_shadow; 
reg [`M+31:0] outputFrame;


reg [14:0] user_data_addr;
wire [7:0] user_data_out;

user_data_ROM_16384_8 user_data_ROM (
  .clka(USER_CLK), // input clka
  .addra(user_data_addr), // input [14 : 0] addra
  .douta(user_data_out) // output [7 : 0] douta
);


wire [7:0] sigdigit_addr;
wire [23:0] sigdigit_out;

sigdigit_ROM_276x24 sigdigit_ROM (
  .clka(USER_CLK), // input clka
  .addra(sigdigit_addr), // input [11 : 0] addra
  .douta(sigdigit_out) // output [1 : 0] douta
);

//---------------------------------------------
/* reed solomon encoder module instantiation */
//---------------------------------------------

reg rs_ce;
wire rs_rdy;
wire rs_info;
wire [7:0] rs_data_out;
wire [7:0] rs_data_in;
reg rs_start;
wire rs_bypass;

reg [7:0] rs_encoded_data [0:255];
reg [7:0] frame_counter;

assign rs_bypass = tied_to_ground_i;

rs_encoder_v7_1 rs_encoder (
        .data_in(rs_data_in), // input [7 : 0] data_in
        .start(rs_start), // input start
        .bypass(rs_bypass), // input bypass
        .data_out(rs_data_out), // output [7 : 0] data_out
        .info(rs_info), // output info
        .rdy(rs_rdy), // output rdy
        .ce(rs_ce), // input ce
        .clk(USER_CLK)); // input clk

assign rs_data_in = user_data_out;


//----------------------------
/* rc4 module instantiation */
//----------------------------
reg [7:0] password[0:`KEY_SIZE-1];
wire rc4_output_ready; // output ready (valid)
wire [9:0] rc4_out; // output
reg [7:0] password_input; //input


reg rc4_ce;
reg rc4_rst;
wire rc4_clk;
assign rc4_clk = USER_CLK & rc4_ce;

rc4 rc4mod_0(
	.clk(rc4_clk),
	.rst(rc4_rst),
	.password_input(password_input),
	.output_ready(rc4_output_ready),
	.K(rc4_out)
);

//----------------------------------
/* Noise rc4 module instantiation */
//----------------------------------
/*
wire [9:0] rc4_noise_out; // output
wire rc4_noise_output_ready; // output ready (valid)

rc4 rc4_noise(
	.clk(USER_CLK),
	.rst(rc4_rst),
	.password_input(password_input),
	.output_ready(rc4_noise_output_ready),
	.K(rc4_noise_out)
);
*/
//----------------------------------
/* Linear congruential generator (RC4 no entra!) */
//----------------------------------

reg [31:0] lcgX;


// Frame State Machine State
reg [3:0] FSMState;
`define FSMS_CRYPTO_INIT    4'h0
`define FSMS_CRYPTO_KEXPAND 4'h1
`define FSMS_RS_START		 4'h2
`define FSMS_RS_DATAOUT		 4'h3
`define FSMS_BLOOMENC		 4'h4
`define FSMS_BLOOMENC_KLOOP 	 4'h5
`define FSMS_END		 4'h6
`define FSMS_WAIT		 4'h7
`define FSMS_FRAME_COPY		 4'h8
`define FSMS_INSERT_NOISE	 4'h9
`define FSMS_INSERT_NOISE_2 4'ha

// --------------------------------------------------------------------------
// ----------------------------------  Bloomfilter transmission state machine
// Transmite continuamente el buffer BloomFilter[256][4096] a la salida
// Oct 30: Inicialmente transmite el buffer no inicializado

reg [64:0] TransmitWordCounter;

`define SYNCStartFrame 32'h1234807F

always @(posedge USER_CLK)
	begin
	if (SYNC) // Emitimos word de sincronizacion
		TX_DATA <= 32'h0134517C; 
	else if(SYSTEM_RESET || ( FSMState == `FSMS_FRAME_COPY )) 
					begin
    					if (NOISE_MODE == 1)
						TX_DATA <= 32'h00000000;
					else	TX_DATA <= 32'haa55aa55;
					if (SYSTEM_RESET)
						TransmitWordCounter <= 0;
					if ( FSMState == `FSMS_FRAME_COPY )
						begin
						outputFrame[`M+31:32]<=bloomfilter;
						// **** DEBUG: Asigna word de sincronizacion
    						//if (NOISE_MODE == 1)
						//	outputFrame[31:0] <= 32'h00000000; /// DEBUG!!! 23-dic-2013 sacar esto!
						//else	outputFrame[31:0] <= `SYNCStartFrame; 
						outputFrame[31:0] <= `SYNCStartFrame; 
						outputFrame[63:32] <= `SYNCStartFrame; 
						$display("*** %dns *** Sending frame %x",$time,bloomfilter);
						end
					end
			else 	begin
					//$display ("TX_DATA<=%08X (%d)",TX_DATA,TransmitWordCounter);
					TransmitWordCounter<=TransmitWordCounter+1; // Incremento contador de words transmitidas
					// Luego el resto voy enviando de a 32 bits todo BloomFilter[256][4096]

					// Shift
					outputFrame[`M-1:0] <= outputFrame[`M+31:32];
					//outputFrame[`M+31:`M] <= 32'h11001100; // Esto significa TX_DATA vacio
					outputFrame[`M+31:`M] <= outputFrame[31:0]; // Rotacion
	
					// Transmit
					TX_DATA <= outputFrame[31:0];
//					$display ("Sent == %08X",outputFrame[31:0]);
					end
	end

// --------------------------------------------------------------------------
// ----------------------------------  Main State machine
// Encodea 223 bytes en user_data_ROM a BloomFilter[256][4096]

reg [14:0] clkcounter; // Multi-use counter (same width as user_data_ROM)
reg [4:0]  WORDLENCount;
reg [4:0] K; //bloomfilter K

assign sigdigit_addr = rs_encoded_data[frame_counter];


reg [16:0] DEBUGCounter; // Borrar

`define KMAX 8'h5
`define WORDLENMAX 8'h18 // 24

always @(posedge USER_CLK)
	begin
        if(SYSTEM_RESET) 
					begin
					clkcounter <= 14'h0000;
					if (NOISE_MODE==1) // Si estamos en modo ruido, pasar directamente a la generacion y saltar crypto/RS
						begin
						bloomfilter <=1024'h0;
						FSMState <= `FSMS_INSERT_NOISE;
						end
					else	FSMState <= `FSMS_CRYPTO_INIT;
					user_data_addr<=14'h0000;
					rs_ce <= 0;
					rs_start<=0;
					rc4_ce <= 1;
					password[0] <= 0;
					password[1] <= 1;
					password[2] <= 2;
					password[3] <= 3;
					password[4] <= 4;
					password[5] <= 5;
					password[6] <= 6;
					password[7] <= 255;
					rc4_rst <= 1;
					blockCounter<=0;
					FRAME_COUNT <=1;
					BUSY<=1;
					// Seed LCG
					lcgX<=32'h00000042; 
					end
        else   if (CS & (!SYNC))
					begin
					DEBUG<=FSMState;
					clkcounter<=clkcounter+1;
					case (FSMState)
						`FSMS_CRYPTO_INIT:	begin // Send rc4 key
									rc4_rst<=0; // Libera de reset
									if (clkcounter<`KEY_SIZE) //Primeros KEY_SIZE clocks se usan para enviar el password a RC4.v
										password_input <= password[clkcounter];
									else	begin // Pasword enviado, pasamos al proximo estado
										FSMState<=`FSMS_CRYPTO_KEXPAND;
										clkcounter<=14'h0000;
										end
									end
						`FSMS_CRYPTO_KEXPAND:begin // Expand rc4 Key
									if (rc4_output_ready==1) // Tenemos que esperar 750 clocks a que RC4 expanda la key
										begin
										FSMState<=`FSMS_RS_START;
										rc4_ce <=0;
										rs_ce <= 1;
										rs_start<=1;
										frame_counter <= 0;
										end
									end
						`FSMS_RS_START:		begin // Start sending RS data
									// Tenemos la key expandida, RC4 esta listo pero con CE apagado, ahora empezamos a encodear la data con reed solomon
									rs_start<=0;
									user_data_addr<=user_data_addr+1;
									rs_encoded_data[frame_counter] <= rs_data_out;
									$display("rs_encoded_data[%d] <= %02X;",frame_counter,rs_data_out);
									//Luego de aprox 3 ciclos, los datos salen por rs_data_out pero ojo, hay que seguirle mandando datos por rs_data_in
									if (rs_rdy)	frame_counter<=frame_counter+1;
									// Cuando tenemos 255 bytes, es un bloque, reed-solomon termino y pasamos a codificar con bloomfilter
									
										begin 
										// TODO: se puede pipelineizar/paralelizar esto??
										FSMState <= `FSMS_BLOOMENC; // Proximo estado
										rs_ce <=0; // Shutdown RS encoder
										WORDLENCount<=0; // Init WORD bit counter
										frame_counter <=0; // Init user data (rs encoded) counter to zero
										// Inicializamos bloomfilter al pattern balanceado electricamente en 8b10b
										bloomfilter <=1024'h3636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636;
										bloomfilter_shadow <=0; // mapa de bits para evitar el ruido de 8b10b de sincronizacion.
										user_data_addr<=14'h0000;
										rs_start<=0;
										DEBUGCounter <= 0;
										end
									end
						// Comienzo del encodeo de Bloomfilter
						// Esto son dos loops anidados: 
						//			* El interior por K
						//			* El exterior por WordLenCount que es la cantidad de bits del simbolo expandido	
						`FSMS_WAIT:		begin
									// Delay para dar tiempo a decodificacion
									BUSY<=0;
									if (clkcounter>=20)
										begin
								   		BUSY<=1;
										FSMState <= `FSMS_BLOOMENC;
										end
									else	clkcounter<=clkcounter+1;
									end
						`FSMS_BLOOMENC:		begin // WORDLEN bloomfilter loop
									// Este estado solamente sirve para inizializar el WORD a mandar por bloomfilter, no realiza
									// el encodeo sino que setupea seniales para el proximo estado
									if (WORDLENCount == `WORDLENMAX) // Si encodie todos los bits
										begin // Esto lo que hace es ciclar por cada bit del simbolo expandido.
											// WORDLENMAX es 24, cuando se llega a 24 bits, se pasa al proximo 
											// simbolo de reedsolomon (Que se encodea en el proximo M)
											// que sera expandido instantaneamente en la tabla de lookup sigdigit_out
										// Init contadores
										WORDLENCount<=0;
										DEBUGCounter <= 0;
										K <= 0;
										// Seed LCG
										//lcgX<=12345; 
										FSMState <= `FSMS_INSERT_NOISE;
										end	
									else 	begin
										K <= 0; // Init K
										FSMState <= `FSMS_BLOOMENC_KLOOP; // Proximo estado
										rc4_ce <=1; // Habilito RC4
										end
									end
						`FSMS_BLOOMENC_KLOOP:begin // K bloomfilter loop
									if (K==`KMAX) // Si llegue al final
										begin
										rc4_ce <=0; // Apago RC4
										FSMState <= `FSMS_BLOOMENC;
										WORDLENCount<=WORDLENCount+1; // Si no, incremento WORDLENCount que es el bit a mandar
										end
									else	begin // Sino
										if (rc4_output_ready==1)
											begin
											// Encodeo en bloomfilter el bit expandido 
											
											// Originalmente la operacion de asignacion al bloomfilter es un OR, pero tuve que cambiarla para mantener el balance electrico en el Bus, y ya no es un bloomfilter
											// bloomfilter[rc4_out[9:0]] <= bloomfilter[rc4_out[9:0]] | sigdigit_out[WORDLENCount];
											if (bloomfilter_shadow[rc4_out[9:0]]==0)
												begin
												bloomfilter[rc4_out[9:0]] <= sigdigit_out[WORDLENCount];
												bloomfilter_shadow[rc4_out[9:0]] <= sigdigit_out[WORDLENCount];
												end
											if ((DEBUGCounter<200) && (frame_counter==4))
												begin
												DEBUGCounter<=DEBUGCounter+1;
												$display("Frame Gen RC4: %d: K=%d rnd=%04X WordLenCount: %d sigdigit_out: %b",DEBUGCounter,K,rc4_out[9:0],WORDLENCount,sigdigit_out);
												end
											K<=K+1; // Incremento K
											end
										end
									end
						`FSMS_INSERT_NOISE: // Paso final: Insertamos ruido en el frame
									begin
									if (NOISE_CLIENTS==0) FSMState <= `FSMS_FRAME_COPY;
									else	begin
										if (DEBUGCounter<NOISE_CLIENTS)
											begin
											DEBUGCounter<=DEBUGCounter+1;
											//lcgX <=lcgX*1103515245+12345; //glibc lcg
											lcgX <=lcgX*69069; //VAX 
											FSMState<=`FSMS_INSERT_NOISE_2;
											end
										else	FSMState <= `FSMS_FRAME_COPY;
										end
									end
						`FSMS_INSERT_NOISE_2: // Insertamos K bits de ruido por cada cliente
									begin
									lcgX <=lcgX+1; //VAX 
									FSMState<=`FSMS_INSERT_NOISE;
									bloomfilter[lcgX[25:16]]<=1;
									end
						`FSMS_FRAME_COPY: 
										begin
										if (NOISE_MODE==1) // En modo de solo-ruido
												begin      // solamente generamos un frame vacio con ruido
												bloomfilter <=1024'h0;
												DEBUGCounter <= 0;
												FSMState <= `FSMS_INSERT_NOISE;
												bloomfilter_shadow <=0;
												end
										else	begin
											// Aqui copiamos el bloomfilter completado al frame de salida outputframe
											$display("*** %dns *** Encoding frame %d ended (byte %x)",$time,frame_counter,rs_encoded_data[frame_counter]);
											// Incrementamos el contador de frame o "simbolo a enviar"
											frame_counter<=frame_counter+1;
											FRAME_COUNT<=FRAME_COUNT+1;
											// Si no tenemos mas bytes para enviar:
											if (frame_counter==8'hff)
												begin // Detenemos la maquina de estados
												FSMState <= `FSMS_END;
												end
											else 	begin
												// Sino, setup para generar proximo frame
												// Inicializamos bloomfilter al pattern balanceado electricamente en 8b10b
												bloomfilter <=1024'h3636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636;
												bloomfilter_shadow <=0;
												FSMState <= `FSMS_WAIT; // Esperamos un delay para sincronizar con decoding
												clkcounter <= 0; // Inicializamos contador del delay
												end
											end
										end
						`FSMS_END:		begin 
									FSMState<=`FSMS_RS_START;
									rc4_ce <=0;
									rs_ce <= 1;
									rs_start<=1;
									frame_counter <= 0;
									blockCounter<=blockCounter+1;
									end
													
						endcase
					end
				else	DEBUG<=16'hffff;
	end

endmodule 


